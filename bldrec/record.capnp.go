// Code generated by capnpc-go. DO NOT EDIT.

package bldrec

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
)

type Record capnp.Struct

// Record_TypeID is the unique identifier for the type Record.
const Record_TypeID = 0xc827ead42acddc80

func NewRecord(s *capnp.Segment) (Record, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Record(st), err
}

func NewRootRecord(s *capnp.Segment) (Record, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Record(st), err
}

func ReadRootRecord(msg *capnp.Message) (Record, error) {
	root, err := msg.Root()
	return Record(root.Struct()), err
}

func (s Record) String() string {
	str, _ := text.Marshal(0xc827ead42acddc80, capnp.Struct(s))
	return str
}

func (s Record) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Record) DecodeFromPtr(p capnp.Ptr) Record {
	return Record(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Record) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Record) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Record) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Record) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Record) UDateTime() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Record) SetUDateTime(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Record) SDescription() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Record) HasSDescription() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Record) SDescriptionBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Record) SetSDescription(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Record) FValue() float32 {
	return math.Float32frombits(capnp.Struct(s).Uint32(8))
}

func (s Record) SetFValue(v float32) {
	capnp.Struct(s).SetUint32(8, math.Float32bits(v))
}

func (s Record) SDontCare() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Record) HasSDontCare() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Record) SDontCareBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Record) SetSDontCare(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// Record_List is a list of Record.
type Record_List = capnp.StructList[Record]

// NewRecord creates a new list of Record.
func NewRecord_List(s *capnp.Segment, sz int32) (Record_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[Record](l), err
}

// Record_Future is a wrapper for a Record promised by a client call.
type Record_Future struct{ *capnp.Future }

func (f Record_Future) Struct() (Record, error) {
	p, err := f.Future.Ptr()
	return Record(p.Struct()), err
}

const schema_9c1e5a2b3d4f6a7b = "x\xda,\xcb1K\xf3P\x18\xc5\xf1s\x9e\x9b\xbc\x85" +
	"\xd2\xf2\xf6BfWAQp-\x88\x82\xdd\xf5)\xe2" +
	"\xe0dH\xaf\x98\x12\x93x{\x03\x82K\xfd\x1eN~" +
	"\x11'A\x87n\x8e\xee\x82_\xe2J\xc4\xe9\xc0\xe1\xff" +
	"\x9b<\x1e'\x07\xe3\x17B4K\xff\xc5\xf5\xe7f\xe7" +
	"\xe3{\xfb\x0d:\xa6\xc4\x87\xe5\xe9\xe1\xee\xe5\xd6\x13R" +
	"\x19\x00\xf6\xf5\xd9n\xfa}\xff\xc2^\xf4\xaeh\xfcb" +
	"\xbf`\xde\xd6\xedt\xee\x8aA\xe3\x17g\xa4NL\x02" +
	"$\x04l>\x07\xf4\xcaP+!\x99\xb1\xff\xca%\xa0" +
	"7\x86\x1a\x84V$\xa3\x00\xf6n\x0ahe\xa8\xf7B" +
	"k\x98\xd1\x00\xb6\xebu0\xd4\xb50v\xb3<\xb8\xf3" +
	"\xf2\x16tL!L\xc1\xb8\x9a\xb9U\xe1\xcb\x16\xffC" +
	"\xd9\xd4\x1cA8\x02\x8f\xae/\xf2\xaas\x1cB8\xfc" +
	"\xad\x9a:\x9c\xe4\xbe\x97\x7f\xc9O\x00\x00\x00\xff\xff\x12" +
	"\xa25\xab"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_9c1e5a2b3d4f6a7b,
		Nodes: []uint64{
			0xc827ead42acddc80,
		},
		Compressed: true,
	})
}
